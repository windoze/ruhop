# GoHop 协议规范

本文档详细描述 GoHop VPN 协议。

## 概述

GoHop 使用基于 UDP 的自定义协议，具有以下特性：
- 预共享密钥认证
- AES-256-CBC 加密配合 Snappy 压缩
- 可配置范围内的端口跳跃
- 包含握手、工作和结束阶段的有状态连接

## 数据包格式

### 传输格式

通过 UDP 传输的每个数据包具有以下结构：

```
+------------------+------------------------+
|   IV (16 字节)   |      加密载荷          |
+------------------+------------------------+
```

- **IV**：用于 AES-CBC 的 16 字节随机初始化向量
- **加密载荷**：AES-256-CBC 加密、Snappy 压缩的数据

### 解密后的数据包结构

解密和解压缩后，数据包具有以下结构：

```
+--------+--------+--------+--------+--------+--------+--------+--------+
| 字节 0 | 字节 1 | 字节 2 | 字节 3 | 字节 4 | 字节 5 | 字节 6 | 字节 7 |
+--------+--------+--------+--------+--------+--------+--------+--------+
|  Flag  |              Seq (uint32, 大端序)          |  Plen (uint16)  |
+--------+--------+--------+--------+--------+--------+--------+--------+

+--------+--------+--------+--------+--------+--------+--------+--------+
| 字节 8 | 字节 9 | 字节10 | 字节11 | 字节12 | 字节13 | 字节14 | 字节15 |
+--------+--------+--------+--------+--------+--------+--------+--------+
|   FragPrefix    |  Frag  |         Sid (uint32)      |  Dlen (uint16) |
+--------+--------+--------+--------+--------+--------+--------+--------+

+--------+--------+--------+--------+--------+
| 字节16 | 字节17 |  ...   |        |        |
+--------+--------+--------+--------+--------+
|              载荷 (Dlen 字节)               |
+--------------------------------------------+
|              噪声 (可选)                    |
+--------------------------------------------+
```

### 头部字段（共 16 字节）

| 字段 | 大小 | 描述 |
|------|------|------|
| Flag | 1 字节 | 数据包类型标志（见下文） |
| Seq | 4 字节 | 序列号（大端序） |
| Plen | 2 字节 | 总载荷长度（用于分片） |
| FragPrefix | 2 字节 | 在原始载荷中的分片偏移 |
| Frag | 1 字节 | 分片索引 |
| Sid | 4 字节 | 会话 ID |
| Dlen | 2 字节 | 此数据包中的实际数据长度 |

### 标志值

标志可以使用按位或组合：

| 标志 | 值 | 描述 |
|------|-------|------|
| HOP_FLG_DAT | 0x00 | 数据包 |
| HOP_FLG_PSH | 0x80 | 端口敲门 / 心跳 |
| HOP_FLG_HSH | 0x40 | 握手 |
| HOP_FLG_FIN | 0x20 | 结束会话 |
| HOP_FLG_PRB | 0x10 | 探测（用于路径丢包检测） |
| HOP_FLG_MFR | 0x08 | 后续还有更多分片 |
| HOP_FLG_ACK | 0x04 | 确认 |

常见标志组合：
- `0x00` (HOP_FLG_DAT)：数据包
- `0x08` (HOP_FLG_DAT | HOP_FLG_MFR)：分片数据，后续还有更多
- `0x80` (HOP_FLG_PSH)：端口敲门或心跳请求
- `0x84` (HOP_FLG_PSH | HOP_FLG_ACK)：心跳确认
- `0x40` (HOP_FLG_HSH)：握手请求
- `0x44` (HOP_FLG_HSH | HOP_FLG_ACK)：握手确认
- `0x60` (HOP_FLG_HSH | HOP_FLG_FIN)：握手错误/拒绝
- `0x20` (HOP_FLG_FIN)：结束会话请求
- `0x24` (HOP_FLG_FIN | HOP_FLG_ACK)：结束确认
- `0x10` (HOP_FLG_PRB)：探测请求（客户端 → 服务器）
- `0x14` (HOP_FLG_PRB | HOP_FLG_ACK)：探测响应（服务器 → 客户端）

## 加密

### 密钥派生

预共享密钥使用 PKCS5 填充到 32 字节用于 AES-256：

```
key = PKCS5Padding(pre_shared_key, 32)
```

### 加密过程

1. 生成 16 字节随机 IV
2. 使用 Snappy 压缩明文
3. 将压缩数据填充到 16 字节边界（PKCS5）
4. 使用 IV 进行 AES-256-CBC 加密
5. 将 IV 前置到密文

### 解密过程

1. 提取前 16 字节作为 IV
2. 使用 AES-256-CBC 解密剩余字节
3. 移除 PKCS5 填充
4. 使用 Snappy 解压

## 会话状态

```
+------------+     knock      +---------------+
|            | -------------> |               |
|  INIT (0)  |                | HANDSHAKE (1) |
|            | <------------- |               |
+------------+    timeout     +---------------+
                                    |
                              handshake_ack
                                    |
                                    v
+------------+     FIN        +---------------+
|            | <------------- |               |
|  FIN (3)   |                | WORKING (2)   |
|            | -------------> |               |
+------------+    FIN_ACK     +---------------+
```

| 状态 | 值 | 描述 |
|------|-------|------|
| HOP_STAT_INIT | 0 | 初始状态，未连接 |
| HOP_STAT_HANDSHAKE | 1 | 握手进行中 |
| HOP_STAT_WORKING | 2 | 会话已建立，数据传输活跃 |
| HOP_STAT_FIN | 3 | 会话终止中 |

## 连接建立

### 端口敲门阶段

在握手之前，客户端向多个服务器端口发送敲门数据包以建立地址映射：

1. 客户端生成随机 4 字节会话 ID（SID）
2. 客户端向跳跃范围内的每个端口发送 PSH 数据包
3. 服务器记录每个端口的客户端地址

**敲门数据包（客户端 -> 服务器）：**
```
Flag: HOP_FLG_PSH (0x80)
Payload: SID (4 字节)
```

**敲门响应（服务器 -> 客户端，如果会话存在）：**
```
Flag: HOP_FLG_PSH | HOP_FLG_ACK (0x84)
Payload: [1 字节]
```

### 握手阶段

敲门后，客户端发起握手：

**握手请求（客户端 -> 服务器）：**
```
Flag: HOP_FLG_HSH (0x40)
Payload: SID (4 字节)
```

**握手响应（服务器 -> 客户端）：**
```
Flag: HOP_FLG_HSH | HOP_FLG_ACK (0x44)
Payload:
  - 协议版本 (1 字节): 0x03
  - 地址数量 (1 字节): 地址数量 (1-255)
  - 每个地址:
    - IP 类型 (1 字节): 0x04 表示 IPv4, 0x06 表示 IPv6
    - IP 地址 (4 或 16 字节): 例如 10.1.1.3 (IPv4) 或 2001:db8::1 (IPv6)
    - 子网掩码/前缀 (1 字节): 例如 24 表示 IPv4, 64 表示 IPv6
```

第一个地址是用于 TUN 接口配置的主地址。
额外地址启用 IP 跳跃 - 客户端可以向服务器公布的任何 IP 地址发送数据包以增强混淆。

**握手确认（客户端 -> 服务器）：**
```
Flag: HOP_FLG_HSH | HOP_FLG_ACK (0x44)
Payload: SID (4 字节)
```

**握手错误（服务器 -> 客户端）：**
```
Flag: HOP_FLG_HSH | HOP_FLG_FIN (0x60)
Payload: 错误消息 (字符串)
```

### 握手超时

- 服务器以 2 秒间隔重试握手响应最多 5 次
- 客户端以随机延迟（尝试之间 0-1000ms）重试敲门/握手
- 如果 5 次重试后仍无响应，服务器踢出对端

## 数据传输

进入 WORKING 状态后，IP 数据包被隧道传输：

**数据包：**
```
Flag: HOP_FLG_DAT (0x00)
Seq: 递增的序列号
Sid: 会话 ID
Dlen: IP 数据包长度
Payload: 来自 TUN 接口的原始 IP 数据包
```

### 端口和 IP 跳跃

端口跳跃是 GoHop 的核心混淆机制。客户端和服务器为每个数据包随机选择目标地址，使流量分析变得困难。

#### 地址池生成

客户端从配置生成地址池：

```
地址池 = 服务器 IP × 端口范围
```

示例：3 个服务器 IP 和端口 4096-4100：
```
server = ["203.0.113.1", "203.0.113.2", "198.51.100.1"]
port_range = [4096, 4100]

地址池（15 个地址）：
  203.0.113.1:4096,  203.0.113.1:4097,  203.0.113.1:4098,  203.0.113.1:4099,  203.0.113.1:4100
  203.0.113.2:4096,  203.0.113.2:4097,  203.0.113.2:4098,  203.0.113.2:4099,  203.0.113.2:4100
  198.51.100.1:4096, 198.51.100.1:4097, 198.51.100.1:4098, 198.51.100.1:4099, 198.51.100.1:4100
```

#### 客户端发送行为

对于发送的**每个数据包**（包括敲门、握手、数据、心跳和 FIN 数据包），客户端：

1. 从池中随机选择一个地址
2. 将数据包发送到该地址
3. 下一个数据包可能发送到完全不同的地址

```
客户端                                              服务器
   |                                                   |
   |-- 敲门 -----> 203.0.113.1:4097 ---------------->|
   |-- 敲门 -----> 198.51.100.1:4099 --------------->|
   |-- 敲门 -----> 203.0.113.2:4096 ---------------->|
   |-- 握手 ----> 203.0.113.1:4100 ---------------->|
   |<-------------- 握手 ACK ------------------------|
   |-- 确认 ----> 198.51.100.1:4097 --------------->|
   |-- 数据 ----> 203.0.113.2:4098 ---------------->|
   |-- 数据 ----> 203.0.113.1:4096 ---------------->|
   |<-------------- 数据 ----------------------------|
   |-- 数据 ----> 198.51.100.1:4100 --------------->|
   |                                                   |
```

#### 服务器套接字架构

服务器在配置范围内**为每个端口绑定一个 UDP 套接字**：

```
[server]
listen = "0.0.0.0"
port_range = [4096, 4100]

创建 5 个套接字：
  套接字 0: 0.0.0.0:4096
  套接字 1: 0.0.0.0:4097
  套接字 2: 0.0.0.0:4098
  套接字 3: 0.0.0.0:4099
  套接字 4: 0.0.0.0:4100
```

每个套接字运行独立的接收循环。套接字索引按客户端会话跟踪。

#### 多宿主服务器 NAT 穿透

当服务器具有多个 IP 地址（多宿主）时，正确的 NAT 穿透需要从接收请求的相同本地 IP 响应。

**问题**：不进行跟踪时，响应可能从错误的源 IP 发出：
```
客户端发送到: 203.0.113.1:4097 (外部) → 10.0.0.1:4097 (内部，通过 DNAT)
服务器响应从: 10.0.0.2:4097 (错误的内部 IP) → 203.0.113.2:4097 (错误的外部，通过 SNAT)
客户端的 NAT 丢弃该数据包（意外的源地址）
```

**解决方案**：服务器使用 `IP_PKTINFO`（Linux）或 `IP_RECVDSTADDR`（macOS）跟踪传入数据包的目标 IP：

```
1. 客户端发送数据包到 203.0.113.1:4097
2. 云 DNAT 转换到 10.0.0.1:4097
3. 服务器接收数据包，内核报告 local_addr = 10.0.0.1:4097
4. 服务器为此会话存储 last_recv_local_addr = 10.0.0.1:4097
5. 服务器使用 sendmsg() 配合 IP_PKTINFO 发送响应，强制源地址 = 10.0.0.1
6. 云 SNAT 转换回 203.0.113.1:4097
7. 客户端从预期地址接收响应
```

#### 会话地址跟踪

服务器为每个客户端会话跟踪：

| 字段 | 描述 |
|------|------|
| `peer_addr` | 客户端当前源地址（IP:端口） |
| `last_recv_socket_idx` | 最后接收此客户端数据的套接字索引 |
| `last_recv_local_addr` | 接收最后一个数据包的本地 IP:端口 |

这些字段在**每个接收到的数据包**上更新，以处理：
- 客户端源端口变化（NAT 重新绑定）
- 客户端在不同服务器 IP 之间跳跃
- 多宿主服务器的正确响应路由

#### 服务器响应行为

当服务器向客户端发送数据包（数据、心跳 ACK 等）时：

1. 使用 `last_recv_socket_idx` 处的套接字
2. 从 `last_recv_local_addr.ip()` 发送以实现多宿主 NAT 穿透
3. 发送到 `peer_addr`（客户端最后已知地址）

这确保响应从接收该客户端最新数据包的相同 IP 发出。

#### 流量模式

典型会话显示数据包分布在各地址：

```
时间    方向       地址                      数据包类型
----    ------    ------                    ----------
0.000   C→S      203.0.113.1:4097          敲门
0.001   C→S      198.51.100.1:4099         敲门
0.002   C→S      203.0.113.2:4096          敲门
0.010   C→S      203.0.113.1:4100          握手
0.095   S→C      203.0.113.1:4100          握手 ACK
0.096   C→S      198.51.100.1:4097         握手确认
0.100   C→S      203.0.113.2:4098          数据
0.102   S→C      203.0.113.2:4098          数据
0.150   C→S      203.0.113.1:4096          数据
0.152   S→C      203.0.113.1:4096          数据
0.200   C→S      198.51.100.1:4100         数据
...
```

#### 优势

1. **流量分析抵抗**：观察者看到发往多个不同地址的数据包
2. **端口封锁规避**：如果一个端口被封锁，其他端口仍然有效
3. **IP 封锁弹性**：多个服务器 IP 提供冗余
4. **NAT 映射多样性**：不同的源端口减少指纹识别

### 数据包排序

- 接收方基于序列号维护有序缓冲区
- 数据包在传递到 TUN 接口之前重新排序
- 缓冲区短暂等待乱序数据包后再刷新

## 心跳 / 保活

服务器发起心跳以检测失效对端：

**心跳请求（服务器 -> 客户端）：**
```
Flag: HOP_FLG_PSH (0x80)
Payload: (空)
```

**心跳响应（客户端 -> 服务器）：**
```
Flag: HOP_FLG_PSH | HOP_FLG_ACK (0x84)
Payload: SID (4 字节)
```

- 服务器每 `PeerTimeout/2` 秒发送心跳
- 如果在 `PeerTimeout` 秒内无响应，对端被踢出
- 客户端定期发送敲门作为保活（可配置 `heartbeat-interval`）

## 路径丢包检测（可选）

启用后，客户端探测每个服务器地址以检测被阻断或丢包率高的网络路径。丢包率高的地址会被临时加入黑名单。

### 探测机制

客户端以轮询方式向地址池中的每个地址发送探测包：

**探测请求（客户端 -> 服务器）：**
```
Flag: HOP_FLG_PRB (0x10)
Seq: 探测 ID（用于关联）
Sid: 会话 ID
Payload: timestamp_ms（8 字节，大端序）用于 RTT 测量
```

**探测响应（服务器 -> 客户端）：**
```
Flag: HOP_FLG_PRB | HOP_FLG_ACK (0x14)
Seq: 探测 ID（原样返回）
Sid: 会话 ID
Payload: timestamp_ms（8 字节，从请求中原样返回）
```

### 丢包检测流程

```
客户端                                              服务器
   |                                                   |
   |-- 探测 (id=1) --> 203.0.113.1:4097 ------------->|
   |<-- 探测 ACK (id=1) ------------------------------|
   |                                                   |
   |-- 探测 (id=2) --> 198.51.100.1:4099 ------------>|
   |                    （无响应 - 被阻断）             |
   |                                                   |
   |-- 探测 (id=3) --> 203.0.113.2:4096 ------------->|
   |<-- 探测 ACK (id=3) ------------------------------|
   |                                                   |
```

### 黑名单机制

- 客户端跟踪每个地址发送的探测数和收到的响应数
- 在发送 `min_probes` 个探测后，如果丢包率 >= `threshold`，该地址被加入黑名单
- 被加入黑名单的地址在选择数据包目标时会被跳过
- 经过 `blacklist_duration` 后，地址会被重新探测，可能恢复

### 配置

```toml
[client.probe]
interval = 10            # 每 10 秒探测每个地址
threshold = 0.5          # 丢包率 >= 50% 时加入黑名单
blacklist_duration = 300 # 黑名单持续 5 分钟
min_probes = 3           # 需要 3 个探测才能做出决定
```

### 优势

1. **自动故障转移**：流量自动避开被阻断的端口/IP
2. **自我修复**：恢复的路径会自动重新启用
3. **低开销**：小型探测包（24 字节）以较低频率发送

## 会话终止

任一方都可以发起终止：

**结束请求：**
```
Flag: HOP_FLG_FIN (0x20)
Payload: SID (4 字节)
```

**结束确认：**
```
Flag: HOP_FLG_FIN | HOP_FLG_ACK (0x24)
Payload: (空)
```

- FIN 数据包发送多次（3 次）以确保可靠性
- 服务器将分配的 IP 释放回池
- 客户端清理路由和接口

## 分片（已禁用）

协议支持用于流量变形的数据包分片，但目前已禁用：

**分片数据包：**
```
Flag: HOP_FLG_DAT | HOP_FLG_MFR (0x08) 用于非最终分片
      HOP_FLG_DAT (0x00) 用于最终分片
Plen: 原始载荷总长度
FragPrefix: 此分片在原始载荷中的偏移
Frag: 分片索引 (0, 1, 2, ...)
Dlen: 此分片数据的长度
```

重组使用序列号关联分片。

## 会话标识

会话通过路由密钥标识：
- 对于 IPv4：64 位密钥（高 32 位：SID，低 32 位：IPv4 地址）
- 对于 IPv6：128 位密钥（SID 异或到 IPv6 地址的高 32 位）

服务器为每个对端维护两个映射：
1. 基于 SID 的密钥用于控制数据包（敲门、握手、心跳）
2. 基于 IP 的密钥用于数据包路由

## 噪声注入

数据包可以在载荷后包含随机噪声字节：
- 添加噪声以抵抗流量分析
- 噪声长度随机（0 到 MTU-64-载荷长度）
- 噪声不包含在 Dlen 中，只有实际载荷包含

## 数据包混淆（可选）

启用数据包混淆时，会应用额外填充以掩盖流量模式：

### 混淆时的传输格式

```
+------------------+------------------------+------------------+
| 后填充 (0-15)    |   IV (16 字节)         | 加密数据         |
+------------------+------------------------+------------------+
```

### 压缩前填充

随机填充字节在数据包数据**之后**、压缩**之前**追加：

```
+------------------+------------------+
| 数据包数据       | 随机填充 (0-N)   |
+------------------+------------------+
         |
         v  (Snappy 压缩)
+--------------------+
| 压缩数据           |
+--------------------+
```

- 在数据包数据后追加随机字节（0-N，N 可配置，默认 16）
- 不需要长度前缀，因为数据包头包含 `Dlen` 告诉接收方实际载荷长度
- 解压后，`Packet::decode()` 使用 `Dlen` 仅提取实际载荷，忽略尾部填充
- 填充后的数据随后被压缩并使用 AES-256-CBC 加密

### 加密后填充

在 IV 之前预置随机字节（0 到 15）使总数据包长度不对齐块边界：

- 无混淆时：`IV (16) + 密文 (16 的倍数)` = 总是块对齐
- 有混淆时：`随机 (0-15) + IV (16) + 密文` = 通常不对齐

解密时通过以下方式确定填充长度：`total_len % 16`
由于 IV 是 16 字节且密文是块对齐的，任何余数必定是填充。

### 混淆优势

1. **数据长度混淆**：加密前填充掩盖实际载荷大小
2. **加密长度混淆**：加密后填充打破块对齐模式
3. **流量分析抵抗**：配合噪声注入，数据包大小变得不可预测
4. **解码零开销**：不需要长度前缀 - 现有头部字段处理

## 协议常量

| 常量 | 值 | 描述 |
|------|-------|------|
| HOP_HDR_LEN | 16 | 头部大小（字节） |
| HOP_PROTO_VERSION | 0x03 | 当前协议版本（支持多地址） |
| IP_TYPE_V4 | 0x04 | IPv4 地址类型标记 |
| IP_TYPE_V6 | 0x06 | IPv6 地址类型标记 |
| cipherBlockSize | 16 | AES 块大小（IV 大小） |
| Default MTU | 1400 | 最大传输单元 |
| IFACE_BUFSIZE | 2000 | 接口读取缓冲区大小 |

## 安全考虑

1. **预共享密钥**：所有安全性取决于密钥保密
2. **无前向保密**：PSK 泄露会暴露所有过去的流量
3. **无重放保护**：序列号未经加密验证
4. **IV 重用风险**：随机 IV 生成；存在碰撞概率
5. **无认证**：不包含 MAC；依赖 Snappy 解压失败进行完整性检查

## 消息流程示例

### IPv4 示例
```
客户端                                          服务器
   |                                               |
   |-------- PSH (敲门, 端口 4001) ------------->>|
   |-------- PSH (敲门, 端口 4002) ------------->>|
   |-------- PSH (敲门, 端口 4003) ------------->>|
   |                    ...                        |
   |                                               |
   |-------- HSH (握手请求) ------------------->>|
   |                                               |
   |<<------- HSH|ACK (IP: 10.1.1.3/24) -----------|
   |                                               |
   |-------- HSH|ACK (确认) ------------------->>|
   |                                               |
   |<<============ DATA (IP 数据包) =============>>|
   |                                               |
   |<<------- PSH (心跳) --------------------------|
   |-------- PSH|ACK (心跳响应) --------------->>|
   |                                               |
   |-------- FIN (终止) ----------------------->>|
   |<<------- FIN|ACK (确认) ----------------------|
   |                                               |
```

### IPv6 示例
```
客户端                                          服务器
   |                                               |
   |-------- PSH (敲门, 端口 4001) ------------->>|
   |-------- PSH (敲门, 端口 4002) ------------->>|
   |                    ...                        |
   |                                               |
   |-------- HSH (握手请求) ------------------->>|
   |                                               |
   |<<-- HSH|ACK (IP: 2001:db8::100/64) -----------|
   |                                               |
   |-------- HSH|ACK (确认) ------------------->>|
   |                                               |
   |<<============ DATA (IPv6 数据包) ===========>>|
   |                                               |
```

### 多地址 IP 跳跃示例
```
客户端                                          服务器（多宿主）
   |                                               |
   |-------- PSH (敲门到 10.0.0.1:4001) -------->>|
   |-------- PSH (敲门到 192.168.1.1:4001) ----->>|
   |-------- PSH (敲门到 10.0.0.1:4002) -------->>|
   |                    ...                        |
   |                                               |
   |-------- HSH (握手请求) ------------------->>|
   |                                               |
   |<<-- HSH|ACK (IP: 10.0.0.1/24,              --|
   |               192.168.1.1/24,                 |
   |               2001:db8::1/64)                 |
   |                                               |
   |-------- HSH|ACK (确认) ------------------->>|
   |                                               |
   |--- DATA 到 10.0.0.1:4001 ----------------->>|
   |--- DATA 到 192.168.1.1:4002 -------------->>|  (IP + 端口跳跃)
   |<<- DATA 从 2001:db8::1:4003 ----------------|
   |--- DATA 到 10.0.0.1:4003 ----------------->>|
   |                                               |
```
